"""
M3 Analyzer Data Models

Models for job-profile matching and application strategy generation.
"""

from datetime import datetime
from enum import Enum

from pydantic import BaseModel, Field


class MatchLevel(str, Enum):
    """Overall compatibility level."""

    EXCELLENT = "excellent"  # 85-100%
    STRONG = "strong"  # 70-84%
    MODERATE = "moderate"  # 50-69%
    WEAK = "weak"  # 30-49%
    POOR = "poor"  # 0-29%


class SkillMatchResult(BaseModel):
    """
    Match between a job requirement and user skills.

    Example:
        requirement_text: "5+ years Python experience"
        matched_skills: ["Python - expert level, 6 years experience"]
        score: 0.92
        is_met: True
    """

    requirement_text: str
    requirement_priority: str  # "must_have", "nice_to_have", "preferred"
    matched_skills: list[str] = Field(default_factory=list)  # Skill descriptions
    score: float = Field(ge=0, le=1)  # Similarity score
    is_met: bool = False
    gap_reason: str | None = None  # Why not met


class ExperienceMatchResult(BaseModel):
    """
    Match between a job responsibility and user experiences.

    Example:
        responsibility_text: "Design REST APIs"
        matched_experience: "Senior Developer at TechCorp"
        relevance_score: 0.85
        matching_keywords: ["API", "REST", "Python"]
    """

    responsibility_text: str
    matched_experience: str | None = None  # Experience title/company
    relevance_score: float = Field(ge=0, le=1)
    matching_keywords: list[str] = Field(default_factory=list)


class QualificationGap(BaseModel):
    """
    An identified gap in qualifications.

    Example:
        requirement: "AWS certification required"
        importance: "must_have"
        gap_type: "certification"
        suggested_action: "Highlight cloud experience, mention willingness to certify"
    """

    requirement: str
    importance: str  # "must_have", "nice_to_have", "preferred"
    gap_type: str  # "skill", "experience", "education", "certification"
    current_level: str | None = None  # What user has
    suggested_action: str = ""


class ApplicationStrategy(BaseModel):
    """
    Strategy for the job application.

    Generated by LLM based on analysis.
    """

    positioning: str  # How to position the application
    key_strengths: list[str] = Field(default_factory=list)  # Top 3-5 strengths
    address_gaps: list[str] = Field(default_factory=list)  # How to address gaps
    tone: str = "professional"  # Recommended tone
    keywords_to_use: list[str] = Field(default_factory=list)  # ATS-friendly keywords
    opening_hook: str | None = None  # Suggested cover letter opening


class CompatibilityScore(BaseModel):
    """
    Detailed compatibility breakdown.
    """

    # Overall
    overall: float = Field(ge=0, le=100)  # Percentage
    level: MatchLevel = MatchLevel.MODERATE

    # Breakdown
    technical_skills: float = Field(ge=0, le=100, default=0)
    experience_relevance: float = Field(ge=0, le=100, default=0)
    requirements_met: float = Field(ge=0, le=100, default=0)  # % of must-haves met

    # Counts
    must_haves_met: int = 0
    must_haves_total: int = 0
    nice_to_haves_met: int = 0
    nice_to_haves_total: int = 0


class AnalysisResult(BaseModel):
    """
    Complete analysis of job-profile match.

    This is the output of the Analyzer module.
    """

    # Identification
    job_id: str
    job_title: str
    company_name: str

    # Scores
    compatibility: CompatibilityScore

    # Detailed matches
    skill_matches: list[SkillMatchResult] = Field(default_factory=list)
    experience_matches: list[ExperienceMatchResult] = Field(default_factory=list)

    # Gaps
    gaps: list[QualificationGap] = Field(default_factory=list)

    # Strategy
    strategy: ApplicationStrategy | None = None

    # Metadata
    analyzed_at: datetime = Field(default_factory=datetime.now)

    @property
    def is_good_match(self) -> bool:
        """Check if this is a good match (70%+)."""
        return self.compatibility.overall >= 70

    @property
    def critical_gaps(self) -> list[QualificationGap]:
        """Get must-have gaps only."""
        return [g for g in self.gaps if g.importance == "must_have"]


class AnalysisInput(BaseModel):
    """
    Input for analysis operation.

    Used by API/web layer to initiate analysis.
    """

    job_id: str  # ID of ProcessedJob from Rinser
    generate_strategy: bool = True  # Whether to generate LLM strategy
